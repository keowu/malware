
"""
 _   __ _____ _____  _    _ _   _
| | / /|  ___|  _  || |  | | | | |
| |/ / | |__ | | | || |  | | | | |
|    \ |  __|| | | || |/\| | | | |
| |\  \| |___\ \_/ /\  /\  / |_| |
\_| \_/\____/ \___/  \/  \/ \___/
                            2023
Copyright (c) Fluxuss Cyber Tech Desenvolvimento de Software, SLU (FLUXUSS)
Copyright (c) Fluxuss Software Security, LLC
Binary files
"""
import json

from LyScript32 import MyDebug
import re
import string


def wait(eip_val):
    while True:
        dbg.set_debug("StepOver")

        eip = dbg.get_register("eip")

        if eip == eip_val:
            break


def get_string_pointer():
    stringx = ""
    i = 0
    while True:
        byte = dbg.read_memory_byte(dbg.get_register("EAX") + i)
        stringx += chr(byte)
        i += 1
        if byte == 0x00:
            break

    return stringx


def get_string_reference():
    stringx = ""
    i = 0
    while True:
        byte = dbg.read_memory_byte(dbg.read_memory_ptr(dbg.get_register("EAX")) + i)
        stringx += chr(byte)
        i += 1
        if byte == 0x00:
            break

    return stringx


def get_fixed_strings(strx):
    printable = set(string.printable)
    r = re.compile(r'\s+')
    strx = (''.join(filter(lambda x: x in printable, strx))).strip(' \t\n\r')
    return r.sub('', strx)


dbg = MyDebug()

connect_flag = dbg.connect()

ref = dbg.is_connect()

encrypted_string_offsets = [
    0x38ACC, 0x3915C, 0x38C1C,
    0x38964, 0x38CAC, 0x38FAC,
    0x393CC, 0x38D6C, 0x38D84,
    0x38D9C, 0x38DB4, 0x38DCC,
    0x38DE4, 0x38DFC, 0x38E14,
    0x38E2C, 0x38E44, 0x38E5C,
    0x38E74, 0x38E8C, 0x38EA4,
    0x38EBC, 0x38ED4, 0x38EEC,
    0x38F04, 0x38F1C, 0x38F34,
    0x38F4C, 0x38F64, 0x38F7C,
    0x38F94, 0x38FAC, 0x38FC4,
    0x38FF4, 0x3900C, 0x39024,
    0x3903C, 0x39054, 0x3906C,
    0x39084, 0x3909C, 0x390B4,
    0x390CC, 0x390E4, 0x390FC,
    0x39114, 0x39144, 0x3915C,
    0x39174, 0x3918C, 0x391A4,
    0x391BC, 0x391D4, 0x391EC,
    0x39204, 0x3921C, 0x39234,
    0x3924C, 0x39264, 0x3927C,
    0x39294, 0x392AC, 0x392C4,
    0x392DC, 0x392F4, 0x3930C,
    0x39324, 0x3933C, 0x39354,
    0x3936C, 0x39384, 0x3939C,
    0x393B4, 0x393CC, 0x393E4,
    0x393FC, 0x39414, 0x3942C,
    0x39444, 0x3945C, 0x39474,
    0x3948C, 0x394A4, 0x394BC,
    0x394D4, 0x394EC, 0x39504,
    0x3951C, 0x39534, 0x3954C,
    0x39564, 0x3957C, 0x3912C,
    0x38D24, 0x38D3C, 0x38C4C,
    0x38C34, 0x38BA4, 0x389F4,
    0x38B2C, 0x389AC, 0x38C64,
    0x38C04, 0x38A84, 0x38A54,
    0x38B8C, 0x389C4, 0x38BEC,
    0x38994, 0x38B14
]

jsonobj = []

for addy in encrypted_string_offsets:
    module_base = dbg.get_module_base("y69lh26.exe")

    # O EIP deve ser definido em module_base+0x986C -> sub esp, 0x18
    dbg.set_register("EIP", (module_base + 0x986C))

    wait(module_base + 0x9871)

    dbg.assemble_at(module_base + 0x9871, "push {}".format(hex(module_base + addy)))

    wait(module_base + 0x9889)

    ida_dict = {
        'IDA_OFFSET': addy,
        'IDA_STR': get_fixed_strings(get_string_pointer()) + get_fixed_strings(get_string_reference()),
        'IDA_OR': get_string_pointer() + get_string_reference()
    }

    jsonobj.append(ida_dict)

    dbg.set_register("EIP", (module_base + 0x986C))

dbg.close()

f = open("out.json", "wb")
f.write(json.dumps(jsonobj).encode())
