/*
 _   __ _____ _____  _    _ _   _
| | / /|  ___|  _  || |  | | | | |
| |/ / | |__ | | | || |  | | | | |
|    \ |  __|| | | || |/\| | | | |
| |\  \| |___\ \_/ /\  /\  / |_| |
\_| \_/\____/ \___/  \/  \/ \___/
                            2023
Copyright (c) Fluxuss Cyber Tech Desenvolvimento de Software, SLU (FLUXUSS)
Copyright (c) Fluxuss Software Security, LLC

*/
#include "decrypt_redline_strings.hh"

auto Base64::base64_encode(const std::string& string) -> std::string {

    std::string out( "" );

    auto val = 0, valb = -6;

    for (auto c : string) {

        val = ( val << 8 ) + c;

        valb += 8;

        while ( valb >= 0 ) {

            out.push_back( b[ ( val >> valb ) & 0x3F ] );

            valb -= 6;

        }
    }

    if ( valb > -6 ) out.push_back( b[ ( ( val << 8 ) >> ( valb + 8 ) ) & 0x3F ] );

    while ( out.size( ) % 4 ) out.push_back( '=' );

    return out;
}

auto Base64::base64_decode(const std::string& string) -> std::string {

    std::string out( "" );

    std::vector< int > T( 256, -1 );

    for ( auto i = 0; i < 64; i++ ) T[ b[ i ] ] = i;

    auto val = 0, valb = -8;

    for ( auto c : string ) {

        if ( T[ c ] == -1 ) break;

        val = ( val << 6 ) + T[ c ];

        valb += 6;

        if ( valb >= 0 ) {

            out.push_back( char( ( val >> valb ) & 0xFF ) );

            valb -= 8;

        }
    }

    return out;
}

auto DecryptRedLine::decryptString(const std::string& string, const std::string& key) -> std::string {

    auto first_round = Base64::base64_decode(string);

    std::string round_three("");

    for (auto i = 0; i < first_round.length(); i++) {
        
        auto utf = (int)(first_round[i] ^ key[i % key.length()]);

        round_three.push_back(utf);

    }
    
    return Base64::base64_decode(round_three);
}